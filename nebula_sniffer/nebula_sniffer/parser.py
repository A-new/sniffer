#!/usr/bin/env python
# -*- coding: utf-8 -*-
import time

from threathunter_common.util import millis_now
from threathunter_common.event import Event

from .msg import HttpMsg

__author__ = "nebula"

parser_registry = {}


class Parser(object):
    """
    Plugins that will extract all kinds of events from messages generated by drivers
    """

    @staticmethod
    def add_parser(name, parser):
        parser_registry[name] = parser

    @staticmethod
    def get_parser(name):
        return parser_registry.get(name)

    def __init__(self):
        pass

    def name(self):
        """
        Get the parser name.
        """

        raise NotImplementedError()

    def get_logbody_config(self):
        """
        Get a list which gives hints whether to capture the http request/response body
        """

        raise NotImplementedError()

    def get_events_from_http_msg(self, http_msg):
        """
        Event parsers will extract events from HttpMsg
        """

        raise NotImplementedError()

    def get_events_from_text_msg(self, text_msg):
        """
        Event parsers will extract events from TextMsg
        """

        raise NotImplementedError()

    def filter(self, msg):
        """
        Filter msg globally
        """

        raise NotImplementedError()


def extract_common_properties(httpmsg):
    if not isinstance(httpmsg, HttpMsg):
        return
    properties = dict()
    properties["c_ip"] = httpmsg.source_ip
    properties["platform"] = ""
    properties["page"] = httpmsg.page
    properties["c_port"] = httpmsg.source_port
    properties["c_bytes"] = httpmsg.req_body_len
    properties["c_body"] = httpmsg.req_body
    properties["c_type"] = httpmsg.req_content_type
    properties["s_ip"] = httpmsg.dest_ip
    properties["s_port"] = httpmsg.dest_port
    properties["s_bytes"] = httpmsg.resp_body_len
    properties["s_body"] = httpmsg.resp_body
    properties["s_type"] = httpmsg.resp_content_type
    properties["host"] = httpmsg.host
    properties["uri_stem"] = httpmsg.uri_stem
    properties["uri_query"] = httpmsg.uri_query
    properties["referer"] = httpmsg.referer
    properties["method"] = httpmsg.method
    properties["status"] = httpmsg.status_code
    properties["cookie"] = httpmsg.req_headers.get("COOKIE", "")
    properties["useragent"] = httpmsg.user_agent
    properties["xforward"] = httpmsg.xforward
    properties["request_time"] = httpmsg.request_time
    properties["request_type"] = ""
    properties["referer_hit"] = "F"
    properties["uid"] = httpmsg.uid
    properties["did"] = httpmsg.did
    properties["sid"] = httpmsg.sid
    # add parent id. the func-order seem terrible now.
    properties["id"] = str(httpmsg.id)
    properties["pid"] = str(httpmsg.id)
    properties["timestamp"] = int(time.time() * 1000)
    properties["is_static"] = httpmsg.is_static

    return properties


def extract_http_log_event(httpmsg):
    if not isinstance(httpmsg, HttpMsg):
        return
    properties = extract_common_properties(httpmsg)

    # remove parent id. the func-order seem terrible now.
    properties["pid"] = "0" * 24
    event_name = "HTTP_STATIC" if properties["is_static"] else "HTTP_DYNAMIC"

    return Event("nebula", event_name, "", millis_now(), properties)
